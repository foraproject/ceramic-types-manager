(function() {
    "use strict";

    var Validator = require('./validator');

    /*
        TODO: Well, this is kinda simplistic.
    */
    var isPrimitiveType = function(type) {
        return ['string', 'number', 'integer', 'boolean', 'array'].indexOf(type) > -1;
    };

    var typeCache = {};

    var TypesManager = function(options) {
        this.validator = new Validator(this);

        if (options) {
            if (options.fn) {
                /*
                    isModel and getDynamicTypeDefinition can also be substituted by deriving from TypesManager
                */
                if (options.fn.isModel)
                    this.isModel = options.fn.isModel;

                if (options.fn.getDynamicTypeDefinition)
                    this.getDynamicTypeDefinition = options.fn.getDynamicTypeDefinition;
            }
        }
    };


    TypesManager.prototype.completeTypeDefinition = function(def) {
        if (!def.schema) {
            def.schema = {};
        }
        if (!def.schema.properties) {
            def.schema.properties = {};
        }
        if (!def.schema.required) {
            def.schema.required = [];
        }
        if (def.autoGenerated) {
            for (var k in def.autoGenerated) {
                def.schema.properties[k] = {
                    type: 'integer'
                };
                def.schema.required.push(k);
            }
        }

        return def;
    };



    TypesManager.prototype.completeVirtualTypeDefinition = function*(virtualTypeDef, baseTypeDefinition) {
        var def = JSON.parse(JSON.stringify(baseTypeDefinition));

        def.baseTypeDefinition = baseTypeDefinition;
        def.name = virtualTypeDef.name;

        for (var kvirt in virtualTypeDef) {
            if (typeof(def[kvirt]) === "undefined" || def[kvirt] === null)
                def[kvirt] = virtualTypeDef[kvirt];
        }

        if (typeof(def.schema) === "undefined" || def.schema === null)
            def.schema = {};

        if (virtualTypeDef.schema) {
            for (var kschema in virtualTypeDef.schema) {
                if (typeof(def.schema[kschema]) === "undefined" || def.schema[kschema] === null)
                    def.schema[kschema] = virtualTypeDef.schema[kschema];
            }
        }

        if (typeof(def.schema.properties) === "undefined" || def.schema.properties === null)
            def.schema.properties = {};

        if (virtualTypeDef.schema && virtualTypeDef.schema.properties) {
            for (var kprop in virtualTypeDef.schema.properties) {
                if (typeof(def.schema.properties[kprop]) === "undefined" || def.schema.properties[kprop] === null)
                    def.schema.properties[kprop] = virtualTypeDef.schema.properties[kprop];
            }
        }

        if (typeof(def.schema.required) === "undefined" || def.schema.required === null)
            def.schema.required = [];

        if (virtualTypeDef.schema && virtualTypeDef.schema.required)
            def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

        return def;
    };



    TypesManager.prototype.buildTypeCache = function*(typeDefinitions, virtualTypeDefinitionsList) {
        var self = this;

        var def, type;

        //Add the base types
        typeDefinitions.forEach(function(def) {
            var fullDef = self.completeTypeDefinition(def);
            typeCache[def.name] = fullDef;
        });

        //Add virtual types
        if (virtualTypeDefinitionsList) {
            for (var i = 0; i < virtualTypeDefinitionsList.length; i++) {
                var vTypeDefs = virtualTypeDefinitionsList[i];
                for(var j = 0; j < vTypeDefs.typeDefinitions.length; j++) {
                    def = yield* self.completeVirtualTypeDefinition(vTypeDefs.typeDefinitions[j], vTypeDefs.baseTypeDefinition);
                    typeCache[def.name] = def;
                }
            }
        }

        //References will resolve now.
        for (type in typeCache) {
            yield* this.resolveReferencesInDef(typeCache[type]);
        }
    };



    TypesManager.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
        var self = this;

        var fn = function*(prop, val) {
            var subTypeDef;
            if (val.type === 'object') {
                if (val.properties) {
                    subTypeDef = {
                        name: "<anonymous>",
                        schema: {
                            type: val.type,
                            properties: val.properties,
                            required: val.required
                        }
                    };
                    prop.typeDefinition = subTypeDef;
                    yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
                }
            } else if (val.$ref) {
                prop.typeDefinition = yield* self.getTypeDefinition(val.$ref, dynamicResolutionContext);
                if (!prop.typeDefinition) {
                    throw new Error("Unable to resolve " + val.$ref);
                }
            }
        };

        for (var property in def.schema.properties) {
            var value = def.schema.properties[property];
            if (value.type === 'array') {
                yield* fn(def.schema.properties[property].items, value.items);
            } else {
                yield* fn(def.schema.properties[property], value);
            }
        }
    };


    /*
        Get all cached type definitions
    */
    TypesManager.prototype.getTypeDefinitions = function() {
        return typeCache;
    };


    /*
        Get a specific type definition based on name, such as "customer" or "apps/forums/1.0.0"
    */
    TypesManager.prototype.getTypeDefinition = function*(name, dynamicResolutionContext) {
        if (typeCache[name])
            return typeCache[name];

        if (!dynamicResolutionContext)
            dynamicResolutionContext = {};

        return dynamicResolutionContext[name] || (yield* this.getDynamicTypeDefinition(name, dynamicResolutionContext));
    };


    /*
        TypeDefinitions that are loaded from the disk or other external sources at runtime.

        Pass this in as options.fn.getDynamicTypeDefinition in constructor
        Or override this if using a derived class.
    */
    TypesManager.prototype.getDynamicTypeDefinition = function*(name, dynamicResolutionContext) {
        throw new Error("resolveDynamicTypeDefinition() method must be overridden in derived class");
    };


    /*
        Pass this in as options.fn.isModel in constructor.
        Or override this if using a derived class
    */
    TypesManager.prototype.isModel = function(value) {
        return false;
    };



    /*
        Gets a virtual type definition if a discriminator exists
    */
    TypesManager.prototype.getEffectiveTypeDefinition = function*(obj, typeDefinition) {
        if (typeDefinition.discriminator) {
            return yield* typeDefinition.discriminator(obj, this);
        } else {
            return typeDefinition;
        }
    };


    /*
        Creates a new instance based on the typeDefinition
    */
    TypesManager.prototype.constructModel = function*(obj, typeDefinition, options) {
        var effectiveTypeDef = yield* this.getEffectiveTypeDefinition(obj, typeDefinition);
        var result = {};
        yield* this.updateModel(result, obj, effectiveTypeDef, options);
        return effectiveTypeDef.ctor ? new effectiveTypeDef.ctor(result) : result;
    };


    /*
        Update fields on target. Target must be an object.
    */
    TypesManager.prototype.updateModel = function*(target, obj, typeDefinition, options) {
        for (var name in typeDefinition.schema.properties) {
            var arr;
            var def = typeDefinition.schema.properties[name];
            var value = obj[name];

            if (!this.isModel(value)) {
                if (isPrimitiveType(def.type)) {
                    if (value !== undefined && value !== null) {
                        if (def.type === 'array') {
                            if (def.items.typeDefinition) {
                                arr = [];
                                for (var _i = 0; _i < value.length; _i++) {
                                    var item = value[_i];
                                    arr.push(yield* this.constructModel(item, def.items.typeDefinition, options));
                                }
                                value = arr;
                            }
                        }
                    }
                } else {
                    if (def.typeDefinition) {
                        if (value) {
                            value = yield* this.constructModel(value, def.typeDefinition, options);
                        }
                    }
                }
            }

            target[name] = value;
        }

        if (options && options.systemFields) {
            options.systemFields.forEach(function(f) {
                target[f] = obj[f];
            });
        }

        if (typeDefinition.autoGenerated) {
            for (var fieldName in typeDefinition.autoGenerated) {
                target[fieldName] = obj[fieldName];
            }
        }
    };


    TypesManager.prototype.validate = function*(obj, typeDefinition) {
        return yield* this.validator.validate(obj, typeDefinition);
	};


    TypesManager.prototype.validateField = function*(obj, value, fieldName, fieldDef) {
        return yield* this.validator.validateField(obj, value, fieldName, fieldDef);
	};


	var initted = false;
    TypesManager.prototype.init = function*(ctors, virtualTypeDefinitions) {
        if (!initted) {
            yield* this.buildTypeCache(ctors, virtualTypeDefinitions);
        } else {
            throw new Error("init() was already called");
        }
    };


    module.exports = TypesManager;

})();
